package thread.Lock;

/**
 * 锁分类
 * 内部锁（重量级锁）：synchronized
 *
 * 显示锁（轻量级锁）：ReentrantLock
 *
 * 偏向锁：当jvm观察到大多数锁并没有被争用，并且这些锁在整个生命周期
 * 只有一个线程占有，虚拟机就会在该线程维护一个偏好，这个线程无论在以后再次申请还是释放该锁，
 * 都不需要原先的CAS操作。
 *
 * 适应性锁：某个线程去申请一个已经被占有的锁，有可能会等很久，也有可能马上就能得到这个锁，这个时间由
 * jvm判断，很久暂停该线程，很快则选择忙盲等策略(原地循环不做任何事)
 *
 * 锁消除：某个临界区代码只被某一个线程访问，则这个锁在JIT编译器中可能被消除
 *
 * 锁粗化：执行的三个方法都在都使用同一个锁，则JIT编译器可以把三个方法的代码优化在同一个临界区。(节省两个锁的性能)
 *
 *
 * 优化多线程：
 * 1）优化锁：
 * 缩小临界区：不需要锁的代码移到非临界区
 * 减小锁的粒度：比如分段锁
 * 考虑锁的替代品：ThreadLocal volatile关键字
 * 2）减少上下文切换
 * 控制线程数量
 * 避免在临界区执行阻塞式IO(占用太长别人来争导致上下文切换)
 * 避免在临界区执行耗时的操作(占用太长别人来争导致上下文切换)
 * 减少Java虚拟机的垃圾回收，回收会导致所有应用线程被暂停
 *
 *
 * 伪对象产生：
 * 多线程创建同一个类实例
 * Java对象内存布局，为了保证不浪费字节空间，例如一个缓存行为64字节。
 * Java中内存布局为8字节对齐。如果一个int类型占了某部分其中四位，其他4位被另一个int占领、
 * 在进行cpu缓存更新得时候可能会把两个值同时更新，导致线程产生缓存未命中，产生额外开销。
 *
 * 解决伪对象办法：
 * 使用@sun.misc.Contended注解，然后开启虚拟机开关。仅在JDK内部类使用
 * 尽量减少对共享变量的访问频率
 * */
public class PackageInfo {
}
